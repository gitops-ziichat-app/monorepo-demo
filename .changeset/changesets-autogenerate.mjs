import { getPackages } from '@manypkg/get-packages';
import writeChangeset from '@changesets/write';
import readChangeset from '@changesets/read';
import path from 'path';
import simpleGit from 'simple-git';

const cwd = process.cwd();
const git = simpleGit(cwd);

async function autogenerateChangeset() {
  console.log('[DEBUG] Starting autogenerateChangeset in directory:', cwd);
  console.log('[DEBUG] Git repository status:', await git.status());

  // Step 1: Get packages
  console.log('[DEBUG] Fetching packages...');
  const { packages, root } = await getPackages(cwd).catch(err => {
    console.error('[ERROR] Failed to fetch packages:', err);
    process.exit(1);
  });
  const allPackages = root ? packages.concat(root) : packages;
  console.log('[DEBUG] Found packages:', allPackages.map(p => ({
    name: p.packageJson.name,
    dir: p.dir
  })));
  if (root) {
    console.log('[DEBUG] Root package:', root.packageJson.name, 'at', root.dir);
  } else {
    console.log('[DEBUG] No root package found.');
  }

  // Step 2: Get changed files from git diff
  console.log('[DEBUG] Running git diffSummary...');
  const diffSummary = await git.diffSummary().catch(err => {
    console.error('[ERROR] Failed to run git diffSummary:', err);
    process.exit(1);
  });
  console.log('[DEBUG] Git diffSummary raw output:', diffSummary);
  const changedFiles = diffSummary.files.map(f => f.file);
  console.log('[DEBUG] Changed files:', changedFiles);

  // Step 3: Check if there are any changed files
  if (changedFiles.length === 0) {
    console.log('[INFO] No changed files detected. Skipping changeset generation.');
    return;
  }

  // Step 4: Map packages to their relative directories
  console.log('[DEBUG] Mapping package directories...');
  const packageDirs = allPackages.map(p => ({ pkg: p, relDir: path.relative(cwd, p.dir) }));
  const sortedPackageDirs = packageDirs.slice().sort((a, b) => b.relDir.length - a.relDir.length);
  console.log('[DEBUG] Package directories (sorted):', sortedPackageDirs.map(p => ({
    name: p.pkg.packageJson.name,
    dir: p.relDir
  })));

  // Step 5: Identify changed packages
  console.log('[DEBUG] Identifying changed packages...');
  const changedPackageNames = new Set();
  for (const file of changedFiles) {
    const pkgEntry = sortedPackageDirs.find(p => file.startsWith(p.relDir));
    if (pkgEntry) {
      console.log('[DEBUG] File', file, 'belongs to package:', pkgEntry.pkg.packageJson.name);
      changedPackageNames.add(pkgEntry.pkg.packageJson.name);
    } else {
      console.log('[DEBUG] File', file, 'does not belong to any package.');
    }
  }

  // Step 6: Check if any packages are affected
  if (changedPackageNames.size === 0) {
    console.log('[INFO] No changes detected in any package. Skipping changeset generation.');
    return;
  }
  console.log('[DEBUG] Changed packages:', Array.from(changedPackageNames));

  // Step 7: Check for existing changesets
  console.log('[DEBUG] Checking for existing changesets...');
  const existingChangesets = await readChangeset(cwd).catch(err => {
    console.error('[ERROR] Failed to read changesets:', err);
    process.exit(1);
  });
  console.log('[DEBUG] Existing changesets:', existingChangesets.map(c => c.id));
  if (existingChangesets.length > 0) {
    console.log('[INFO] Existing changesets found. Skipping autogeneration.');
    return;
  }

  // Step 8: Create releases
  console.log('[DEBUG] Creating releases for changed packages...');
  const releases = Array.from(changedPackageNames).map(name => ({
    name,
    type: 'patch'
  }));
  console.log('[DEBUG] Releases:', releases);

  // Step 9: Write changeset
  const summary = 'chore(release): bump version via CI';
  console.log('[DEBUG] Writing changeset with summary:', summary);
  try {
    const changesetPath = await writeChangeset(summary, releases, { cwd });
    console.log('[INFO] Autogenerated changeset:', path.basename(changesetPath));
    console.log('[DEBUG] Full changeset path:', changesetPath);
  } catch (error) {
    console.error('[ERROR] Failed to autogenerate changeset:', error);
    process.exit(1);
  }
}

autogenerateChangeset();