import { getPackages } from '@manypkg/get-packages';
import writeChangeset from '@changesets/write';
import readChangeset from '@changesets/read';
import path from 'path';
import simpleGit from 'simple-git';

const cwd = process.cwd();
const git = simpleGit(cwd);

async function autogenerateChangeset() {
  const { packages, root } = await getPackages(cwd);
  const allPackages = root ? packages.concat(root) : packages;

  const diffSummary = await git.diffSummary();
  const changedFiles = diffSummary.files.map(f => f.file);

  if (changedFiles.length === 0) {
    console.log("No changed files detected. Skipping changeset generation.");
    return;
  }

  const packageDirs = allPackages.map(p => ({ pkg: p, relDir: path.relative(cwd, p.dir) }));
  const sortedPackageDirs = packageDirs.slice().sort((a, b) => b.relDir.length - a.relDir.length);

  const changedPackageNames = new Set();
  for (const file of changedFiles) {
    const pkgEntry = sortedPackageDirs.find(p => file.startsWith(p.relDir));
    if (pkgEntry) {
      changedPackageNames.add(pkgEntry.pkg.packageJson.name);
    }
  }

  if (changedPackageNames.size === 0) {
    console.log("No changes detected in any package. Skipping changeset generation.");
    return;
  }

  const existingChangesets = await readChangeset(cwd);
  if (existingChangesets.length > 0) {
    console.log("Existing changesets found. Skipping autogeneration.");
    return;
  }

  const releases = Array.from(changedPackageNames).map(name => {
    return { name, type: "patch" }; // Default to 'patch' for autogenerated changesets
  });

  const summary = "chore(release): bump version via CI";

  try {
    const changesetPath = await writeChangeset(summary, releases, { cwd });
    console.log(`Autogenerated changeset: ${path.basename(changesetPath)}`);
  } catch (error) {
    console.error("Failed to autogenerate changeset:", error);
    process.exit(1);
  }
}

autogenerateChangeset();